<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    const Person = function() {
        this.skill = function() {
            console.log('我现在啥也不会')
        }
    }
    
    const Animal = function() {
        this.skill = function() {
            console.log('我是动物，我会个啥')
        }
    }

    const addSkill = function(fun) {
        this.skill = fun.skill
        this.newSkill = function() {
            console.log('我升级了，有新技能')
        }
        this.allSkill = function() {
            this.skill()
            this.newSkill()
        }
    }

    const person = new Person()
    const animal = new Animal()

    const newPerson = new addSkill(person)
    const newAnimal = new addSkill(animal)

    newPerson.allSkill()
    newAnimal.allSkill()

    /*
    继承和装饰器模式的区别:
    装饰器: 把方法来过来，添加公共的
    继承是: 把公共的继承过来，添加私有的
    */

    /*
    代理模式和装饰器模式的区别:
    装饰模式主要是强调对类中代码的拓展，而代理模式则偏向于委托类的访问限制(过滤)。
    当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器
    */
</script>
</html>